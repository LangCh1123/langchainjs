import CodeBlock from "@theme/CodeBlock";
import Example from "@examples/guides/expression_language/runnable_history.ts";

# Add message history (memory)

The `RunnableWithMessageHistory` let's us add message history to certain types of chains.

Specifically, it can be used for any Runnable that takes as input one of

- a list of `BaseMessage`
- an object with a key that takes a list of `BaseMessage`
- an object with a key that takes the latest message(s) as a string or list of `BaseMessage`, and a separate key that takes historical messages

And returns as output one of

- a string that can be treated as the contents of an `AIMessage`
- a list of `BaseMessage`
- an object with a key that contains a list of `BaseMessage`

Let's take a look at some examples to see how it works.

<CodeBlock language="typescript">{Example}</CodeBlock>

## Pass config through the constructor

You don't always have to pass the `config` object through the `invoke` method. `RunnableWithMessageHistory` supports passing it through the constructor as well.

To do this, the only change you need to make is remove the second arg (or just the `configurable` key from the second arg) from the `invoke` method, and add it in through the `config` key in the constructor.

This is a simple example building on top of what we have above:

```typescript
const config: RunnableConfig = { configurable: { sessionId: "1" } };

const withHistory = new RunnableWithMessageHistory({
  runnable,
  getMessageHistory: (_sessionId: string) => messageHistory,
  inputMessagesKey: "input",
  historyMessagesKey: "history",
  // Passing config through here instead of through the invoke method
  config,
});

let output = await withHistory.invoke({ input: "Hello there, I'm Archibald!" });
console.log("output 1:", output);
/**
output 1: AIMessage {
  lc_namespace: [ 'langchain_core', 'messages' ],
  content: 'Hello, Archibald! How can I assist you today?',
  additional_kwargs: { function_call: undefined, tool_calls: undefined }
}
 */
```
