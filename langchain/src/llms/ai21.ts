import { LLM } from "./base.js";
import { getEnvironmentVariable } from "../util/env.js";

interface AI21PenaltyData {
  scale: number;
  applyToWhitespaces: boolean;
  applyToPunctuations: boolean;
  applyToNumbers: boolean;
  applyToStopwords: boolean;
  applyToEmojis: boolean;
}

interface AI21ParseCallOptions {
  stop?: string[];
}

class AI21PenaltyData implements AI21PenaltyData {
  constructor() {
    this.scale = 0;
    this.applyToWhitespaces = true;
    this.applyToPunctuations = true;
    this.applyToNumbers = true;
    this.applyToStopwords = true;
    this.applyToEmojis = true;
  }
}

export class AI21 extends LLM {
  model: string;

  temperature: number;

  maxTokens: number;

  minTokens: number;

  topP: number;

  presencePenalty: AI21PenaltyData;

  countPenalty: AI21PenaltyData;

  frequencyPenalty: AI21PenaltyData;

  numResults: number;

  logitBias?: { [key: string]: number } | null;

  ai21_api_key?: string;

  stop?: string[];

  base_url?: string;

  constructor(fields: Partial<AI21>) {
    console.log("BEING CREATED!");
    super(fields ?? {});

    this.model = fields?.model ?? "j2-jumbo-instruct";
    this.temperature = fields?.temperature ?? 0.7;
    this.maxTokens = fields?.maxTokens ?? 256;
    this.minTokens = fields?.minTokens ?? 0;
    this.topP = fields?.topP ?? 1;
    this.presencePenalty = fields?.presencePenalty ?? new AI21PenaltyData();
    this.countPenalty = fields?.countPenalty ?? new AI21PenaltyData();
    this.frequencyPenalty = fields?.frequencyPenalty ?? new AI21PenaltyData();
    this.numResults = fields?.numResults ?? 1;
    this.logitBias = fields?.logitBias;
    this.ai21_api_key =
      fields?.ai21_api_key ??
      getEnvironmentVariable("AI21_API_KEY") ??
      getEnvironmentVariable("ai21_api_key");
    this.stop = fields?.stop;
    this.base_url = fields?.base_url;
  }

  validateEnvironment() {
    if (!this.ai21_api_key) {
      throw new Error("AI21 API Key is missing in environment variables.");
    }
  }

  /** Get the type of LLM. */
  _llmType() {
    return "ai21";
  }

  /** Get the default parameters for calling AI21 API. */
  get defaultParams() {
    return {
      temperature: this.temperature,
      maxTokens: this.maxTokens,
      minTokens: this.minTokens,
      topP: this.topP,
      presencePenalty: this.presencePenalty,
      countPenalty: this.countPenalty,
      frequencyPenalty: this.frequencyPenalty,
      numResults: this.numResults,
      logitBias: this.logitBias,
    };
  }

  /** Get the identifying parameters for this LLM. */
  get identifyingParams() {
    return { ...{ model: this.model }, ...this.defaultParams };
  }

  /**
   * Returns the type of LLM
   */
  _llm_type() {
    return "ai21";
  }

  /** Call out to AI21's complete endpoint.
   Args:
       prompt: The prompt to pass into the model.
   stop: Optional list of stop words to use when generating.
   
       Returns:
   The string generated by the model.
   
   Example:
   let response = ai21._call("Tell me a joke.");
   */
  async _call(prompt: string, options: AI21ParseCallOptions): Promise<string> {
    let stop = options?.stop;
    this.validateEnvironment();
    if (this.stop && stop && this.stop.length > 0 && stop.length > 0) {
      throw new Error("`stop` found in both the input and default params.");
    }
    stop = (this.stop as string[]) || stop || [];

    let { base_url } = this;
    if (!base_url) {
      base_url =
        this.model === "j1-grande-instruct"
          ? "https://api.ai21.com/studio/v1/experimental"
          : "https://api.ai21.com/studio/v1";
    }

    const url = `${base_url}/${this.model}/complete`;
    const headers = {
      Authorization: `Bearer ${this.ai21_api_key}`,
      "Content-Type": "application/json",
    };
    const data = { prompt, stopSequences: stop, ...this.defaultParams };
    const response = await fetch(url, {
      method: "POST",
      headers,
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      throw new Error(
        `AI21 /complete call failed with status code ${response.status}`
      );
    }

    const responseData = await response.json();

    if (!responseData.completions || responseData.completions.length === 0) {
      throw new Error("No completions found in response");
    }

    return responseData.completions[0].data.text;
  }
}
